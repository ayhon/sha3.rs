-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [simple]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace simple

/- [simple::L]
   Source: 'src/simple.rs', lines 3:0-3:20 -/
@[global_simps] def L_body : Result Usize := ok 6#usize
@[global_simps, irreducible] def L : Usize := eval_global L_body

/- [simple::W]
   Source: 'src/simple.rs', lines 4:0-4:23 -/
@[global_simps] def W_body : Result Usize := 1#usize <<< L
@[global_simps, irreducible] def W : Usize := eval_global W_body (by native_decide)

/- [simple::B]
   Source: 'src/simple.rs', lines 5:0-5:24 -/
@[global_simps]
def B_body : Result Usize := do
                             let i ← 5#usize * 5#usize
                             i * W
@[global_simps, irreducible] def B : Usize := eval_global B_body (by native_decide)

/- [simple::NR]
   Source: 'src/simple.rs', lines 6:0-6:21 -/
@[global_simps] def NR_body : Result Usize := ok 24#usize
@[global_simps, irreducible] def NR : Usize := eval_global NR_body

/- [simple::binxor]:
   Source: 'src/simple.rs', lines 8:0-10:1 -/
def binxor (a : Bool) (b : Bool) : Result Bool :=
  if a
  then if b
       then ok (¬ true)
       else ok true
  else if b
       then ok (¬ false)
       else ok false

/- [simple::xor_long_at]: loop 0:
   Source: 'src/simple.rs', lines 16:4-19:5 -/
def xor_long_at_loop
  (s : Slice Bool) (other : Slice Bool) (pos : Usize) (n : Usize)
  (pos1 : Usize) :
  Result (Slice Bool)
  :=
  if pos1 < n
  then
    do
    let b ← Slice.index_usize s pos1
    let i ← pos1 - pos
    let b1 ← Slice.index_usize other i
    let b2 ← binxor b b1
    let s1 ← Slice.update s pos1 b2
    let i1 ← pos1 + 1#usize
    xor_long_at_loop s1 other pos n i1
  else ok s
partial_fixpoint

/- [simple::xor_long_at]:
   Source: 'src/simple.rs', lines 12:0-20:1 -/
def xor_long_at
  (s : Slice Bool) (other : Slice Bool) (pos : Usize) : Result (Slice Bool) :=
  do
  let i := Slice.len s
  let i1 := Slice.len other
  let i2 ← i1 + pos
  let n ← (↑(core.cmp.impls.OrdUsize.min i i2) : Result Usize)
  xor_long_at_loop s other pos n pos

/- [simple::xor_long]:
   Source: 'src/simple.rs', lines 21:0-23:1 -/
def xor_long (s : Slice Bool) (other : Slice Bool) : Result (Slice Bool) :=
  xor_long_at s other 0#usize

/- [simple::StateArray]
   Source: 'src/simple.rs', lines 25:0-25:29 -/
@[reducible] def StateArray := (Array Bool 1600#usize)

/- [simple::{core::default::Default for simple::StateArray}::default]:
   Source: 'src/simple.rs', lines 28:4-30:5 -/
def DefaultsimpleStateArray.default : Result StateArray :=
  let a := Array.repeat 1600#usize false
  ok a

/- Trait implementation: [simple::{core::default::Default for simple::StateArray}]
   Source: 'src/simple.rs', lines 27:0-31:1 -/
@[reducible]
def core.default.DefaultsimpleStateArray : core.default.Default StateArray := {
  default := DefaultsimpleStateArray.default
}

/- [simple::{core::clone::Clone for simple::StateArray}#1::clone]:
   Source: 'src/simple.rs', lines 34:4-36:5 -/
def ClonesimpleStateArray.clone (self : StateArray) : Result StateArray :=
  ok self

/- Trait implementation: [simple::{core::clone::Clone for simple::StateArray}#1]
   Source: 'src/simple.rs', lines 33:0-37:1 -/
@[reducible]
def core.clone.ClonesimpleStateArray : core.clone.Clone StateArray := {
  clone := ClonesimpleStateArray.clone
}

/- [simple::{simple::StateArray}#2::index]:
   Source: 'src/simple.rs', lines 40:4-43:5 -/
def StateArray.index
  (self : StateArray) (index : (Usize × Usize × Usize)) : Result Bool :=
  do
  let (x, y, z) := index
  let i ← 5#usize * y
  let i1 ← i + x
  let i2 ← W * i1
  let i3 ← i2 + z
  Array.index_usize self i3

/- [simple::{simple::StateArray}#2::index_mut]:
   Source: 'src/simple.rs', lines 45:4-48:5 -/
def StateArray.index_mut
  (self : StateArray) (index : (Usize × Usize × Usize)) :
  Result (Bool × (Bool → StateArray))
  :=
  do
  let (x, y, z) := index
  let i ← 5#usize * y
  let i1 ← i + x
  let i2 ← W * i1
  let i3 ← i2 + z
  let (b, index_mut_back) ← Array.index_mut_usize self i3
  let back := fun ret => let a := index_mut_back ret
                         a
  ok (b, back)

/- [simple::theta::c]:
   Source: 'src/simple.rs', lines 52:4-66:5 -/
def theta.c (a : StateArray) (x : Usize) (z : Usize) : Result Bool :=
  do
  let b ← StateArray.index a (x, 0#usize, z)
  let b1 ← StateArray.index a (x, 1#usize, z)
  let b2 ← StateArray.index a (x, 2#usize, z)
  let b3 ← StateArray.index a (x, 3#usize, z)
  let b4 ← StateArray.index a (x, 4#usize, z)
  let b5 ← binxor b3 b4
  let b6 ← binxor b2 b5
  let b7 ← binxor b1 b6
  binxor b b7

/- [simple::theta::d]:
   Source: 'src/simple.rs', lines 67:4-72:5 -/
def theta.d (a : StateArray) (x : Usize) (z : Usize) : Result Bool :=
  do
  let i ← x + 4#usize
  let x1 ← i % 5#usize
  let i1 ← x + 1#usize
  let x2 ← i1 % 5#usize
  let i2 ← W - 1#usize
  let i3 ← z + i2
  let z2 ← i3 % W
  let b ← theta.c a x1 z
  let b1 ← theta.c a x2 z2
  binxor b b1

/- [simple::theta::inner::inner]: loop 0:
   Source: 'src/simple.rs', lines 82:20-85:21 -/
def theta.inner.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let b ← StateArray.index a (x, y, z)
    let b1 ← theta.d a x z
    let b2 ← binxor b b1
    let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b2
    theta.inner.inner_loop res1 a x y z1
  else ok res
partial_fixpoint

/- [simple::theta::inner::inner]:
   Source: 'src/simple.rs', lines 80:26-86:17 -/
@[reducible]
def theta.inner.inner
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  theta.inner.inner_loop res a x y 0#usize

/- [simple::theta::inner]: loop 0:
   Source: 'src/simple.rs', lines 79:12-88:13 -/
def theta.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  if y < 5#usize
  then
    do
    let res1 ← theta.inner.inner res a x y
    let y1 ← y + 1#usize
    theta.inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [simple::theta::inner]:
   Source: 'src/simple.rs', lines 76:18-89:9 -/
@[reducible]
def theta.inner
  (res : StateArray) (a : StateArray) (x : Usize) : Result StateArray :=
  theta.inner_loop res a x 0#usize

/- [simple::theta]: loop 0:
   Source: 'src/simple.rs', lines 75:4-91:5 -/
def theta_loop
  (a : StateArray) (res : StateArray) (x : Usize) : Result StateArray :=
  if x < 5#usize
  then
    do
    let res1 ← theta.inner res a x
    let x1 ← x + 1#usize
    theta_loop a res1 x1
  else ok res
partial_fixpoint

/- [simple::theta]:
   Source: 'src/simple.rs', lines 51:0-93:1 -/
def theta (a : StateArray) : Result StateArray :=
  do
  let res ← DefaultsimpleStateArray.default
  theta_loop a res 0#usize

/- [simple::rho_offset]:
   Source: 'src/simple.rs', lines 95:0-97:1 -/
def rho_offset (t : Usize) : Result Usize :=
  do
  let i ← t + 1#usize
  let i1 ← t + 2#usize
  let i2 ← i * i1
  let i3 ← i2 / 2#usize
  i3 % W

/- [simple::rho::inner]: loop 0:
   Source: 'src/simple.rs', lines 105:12-109:13 -/
def rho.inner_loop
  (res : StateArray) (a : StateArray) (t : Usize) (x : Usize) (y : Usize)
  (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let i ← rho_offset t
    let i1 ← W - i
    let i2 ← z + i1
    let z2 ← i2 % W
    let b ← StateArray.index a (x, y, z2)
    let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b
    rho.inner_loop res1 a t x y z1
  else ok res
partial_fixpoint

/- [simple::rho::inner]:
   Source: 'src/simple.rs', lines 103:18-110:9 -/
@[reducible]
def rho.inner
  (res : StateArray) (a : StateArray) (t : Usize) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  rho.inner_loop res a t x y 0#usize

/- [simple::rho]: loop 0:
   Source: 'src/simple.rs', lines 102:4-113:5 -/
def rho_loop
  (a : StateArray) (x : Usize) (y : Usize) (res : StateArray) (t : Usize) :
  Result StateArray
  :=
  if t < 24#usize
  then
    do
    let res1 ← rho.inner res a t x y
    let i ← 2#usize * x
    let i1 ← 3#usize * y
    let i2 ← i + i1
    let y1 ← i2 % 5#usize
    let t1 ← t + 1#usize
    rho_loop a y y1 res1 t1
  else ok res
partial_fixpoint

/- [simple::rho]:
   Source: 'src/simple.rs', lines 98:0-115:1 -/
def rho (a : StateArray) : Result StateArray :=
  do
  let res ← ClonesimpleStateArray.clone a
  rho_loop a 1#usize 0#usize res 0#usize

/- [simple::pi::inner::inner]: loop 0:
   Source: 'src/simple.rs', lines 126:20-131:21 -/
def pi.inner.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let i ← 3#usize * y
    let i1 ← x + i
    let x2 ← i1 % 5#usize
    let b ← StateArray.index a (x2, x, z)
    let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b
    pi.inner.inner_loop res1 a x y z1
  else ok res
partial_fixpoint

/- [simple::pi::inner::inner]:
   Source: 'src/simple.rs', lines 124:26-132:17 -/
@[reducible]
def pi.inner.inner
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  pi.inner.inner_loop res a x y 0#usize

/- [simple::pi::inner]: loop 0:
   Source: 'src/simple.rs', lines 123:12-134:13 -/
def pi.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  if y < 5#usize
  then
    do
    let res1 ← pi.inner.inner res a x y
    let y1 ← y + 1#usize
    pi.inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [simple::pi::inner]:
   Source: 'src/simple.rs', lines 121:18-135:9 -/
@[reducible]
def pi.inner
  (res : StateArray) (a : StateArray) (x : Usize) : Result StateArray :=
  pi.inner_loop res a x 0#usize

/- [simple::pi]: loop 0:
   Source: 'src/simple.rs', lines 120:4-137:5 -/
def pi_loop
  (a : StateArray) (res : StateArray) (x : Usize) : Result StateArray :=
  if x < 5#usize
  then
    do
    let res1 ← pi.inner res a x
    let x1 ← x + 1#usize
    pi_loop a res1 x1
  else ok res
partial_fixpoint

/- [simple::pi]:
   Source: 'src/simple.rs', lines 117:0-139:1 -/
def pi (a : StateArray) : Result StateArray :=
  do
  let res ← ClonesimpleStateArray.clone a
  pi_loop a res 0#usize

/- [simple::chi::inner::inner]: loop 0:
   Source: 'src/simple.rs', lines 150:20-156:21 -/
def chi.inner.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let i ← x + 1#usize
    let x1 ← i % 5#usize
    let i1 ← x + 2#usize
    let x2 ← i1 % 5#usize
    let b ← StateArray.index a (x, y, z)
    let b1 ← StateArray.index a (x1, y, z)
    let b2 ← binxor b1 true
    if b2
    then
      do
      let b3 ← StateArray.index a (x2, y, z)
      let b4 ← binxor b b3
      let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
      let z1 ← z + 1#usize
      let res1 := index_mut_back b4
      chi.inner.inner_loop res1 a x y z1
    else
      do
      let b3 ← binxor b false
      let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
      let z1 ← z + 1#usize
      let res1 := index_mut_back b3
      chi.inner.inner_loop res1 a x y z1
  else ok res
partial_fixpoint

/- [simple::chi::inner::inner]:
   Source: 'src/simple.rs', lines 148:26-157:17 -/
@[reducible]
def chi.inner.inner
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  chi.inner.inner_loop res a x y 0#usize

/- [simple::chi::inner]: loop 0:
   Source: 'src/simple.rs', lines 147:12-159:13 -/
def chi.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  if y < 5#usize
  then
    do
    let res1 ← chi.inner.inner res a x y
    let y1 ← y + 1#usize
    chi.inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [simple::chi::inner]:
   Source: 'src/simple.rs', lines 145:18-160:9 -/
@[reducible]
def chi.inner
  (res : StateArray) (a : StateArray) (x : Usize) : Result StateArray :=
  chi.inner_loop res a x 0#usize

/- [simple::chi]: loop 0:
   Source: 'src/simple.rs', lines 144:4-162:5 -/
def chi_loop
  (a : StateArray) (res : StateArray) (x : Usize) : Result StateArray :=
  if x < 5#usize
  then
    do
    let res1 ← chi.inner res a x
    let x1 ← x + 1#usize
    chi_loop a res1 x1
  else ok res
partial_fixpoint

/- [simple::chi]:
   Source: 'src/simple.rs', lines 141:0-164:1 -/
def chi (a : StateArray) : Result StateArray :=
  do
  let res ← ClonesimpleStateArray.clone a
  chi_loop a res 0#usize

/- [simple::IOTA_RC_POINTS]
   Source: 'src/simple.rs', lines 167:0-181:15 -/
@[global_simps]
def IOTA_RC_POINTS_body : Result (Array Bool 255#usize) :=
  ok
    (Array.make 255#usize [
      true, false, false, false, false, false, false, false, true, false, true,
      true, false, false, false, true, true, true, true, false, true, false,
      false, false, false, true, true, true, true, true, true, true, true,
      false, false, true, false, false, false, false, true, false, true, false,
      false, true, true, true, true, true, false, true, false, true, false,
      true, false, true, true, true, false, false, false, false, false, true,
      true, false, false, false, true, false, true, false, true, true, false,
      false, true, true, false, false, true, false, true, true, true, true,
      true, true, false, true, true, true, true, false, false, true, true,
      false, true, true, true, false, true, true, true, false, false, true,
      false, true, false, true, false, false, true, false, true, false, false,
      false, true, false, false, true, false, true, true, false, true, false,
      false, false, true, true, false, false, true, true, true, false, false,
      true, true, true, true, false, false, false, true, true, false, true,
      true, false, false, false, false, true, false, false, false, true, false,
      true, true, true, false, true, false, true, true, true, true, false,
      true, true, false, true, true, true, true, true, false, false, false,
      false, true, true, false, true, false, false, true, true, false, true,
      false, true, true, false, true, true, false, true, false, true, false,
      false, false, false, false, true, false, false, true, true, true, false,
      true, true, false, false, true, false, false, true, false, false, true,
      true, false, false, false, false, false, false, true, true, true, false,
      true, false, false, true, false, false, false, true, true, true, false,
      false, false
      ] (by native_decide))
@[global_simps, irreducible]
def IOTA_RC_POINTS : Array Bool 255#usize := eval_global IOTA_RC_POINTS_body (by native_decide)

/- [simple::iota_rc_point]:
   Source: 'src/simple.rs', lines 183:0-187:1 -/
def iota_rc_point (t : Usize) : Result Bool :=
  do
  let t1 ← t % 255#usize
  Array.index_usize IOTA_RC_POINTS t1

/- [simple::iota_rc_init]: loop 0:
   Source: 'src/simple.rs', lines 191:4-194:5 -/
def iota_rc_init_loop
  (ir : Usize) (rc : Array Bool 64#usize) (j : Usize) :
  Result (Array Bool 64#usize)
  :=
  if j <= L
  then
    do
    let i ← 7#usize * ir
    let i1 ← j + i
    let b ← iota_rc_point i1
    let i2 ← 1#usize <<< j
    let i3 ← i2 - 1#usize
    let rc1 ← Array.update rc i3 b
    let j1 ← j + 1#usize
    iota_rc_init_loop ir rc1 j1
  else ok rc
partial_fixpoint

/- [simple::iota_rc_init]:
   Source: 'src/simple.rs', lines 189:0-195:1 -/
@[reducible]
def iota_rc_init
  (ir : Usize) (rc : Array Bool 64#usize) : Result (Array Bool 64#usize) :=
  iota_rc_init_loop ir rc 0#usize

/- [simple::iota_a]: loop 0:
   Source: 'src/simple.rs', lines 199:4-202:5 -/
def iota_a_loop
  (res : StateArray) (a : StateArray) (rc : Array Bool 64#usize) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let b ← StateArray.index a (0#usize, 0#usize, z)
    let b1 ← Array.index_usize rc z
    let b2 ← binxor b b1
    let (_, index_mut_back) ← StateArray.index_mut res (0#usize, 0#usize, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b2
    iota_a_loop res1 a rc z1
  else ok res
partial_fixpoint

/- [simple::iota_a]:
   Source: 'src/simple.rs', lines 197:0-203:1 -/
@[reducible]
def iota_a
  (res : StateArray) (a : StateArray) (rc : Array Bool 64#usize) :
  Result StateArray
  :=
  iota_a_loop res a rc 0#usize

/- [simple::iota]:
   Source: 'src/simple.rs', lines 205:0-211:1 -/
def iota (ir : Usize) (a : StateArray) : Result StateArray :=
  do
  let rc := Array.repeat 64#usize false
  let rc1 ← iota_rc_init ir rc
  let res ← ClonesimpleStateArray.clone a
  iota_a res a rc1

/- [simple::round]:
   Source: 'src/simple.rs', lines 213:0-219:1 -/
def round (a : StateArray) (ir : Usize) : Result StateArray :=
  do
  let a1 ← theta a
  let a2 ← rho a1
  let a3 ← pi a2
  let a4 ← chi a3
  iota ir a4

/- [simple::keccak_p_aux]: loop 0:
   Source: 'src/simple.rs', lines 223:4-226:5 -/
def keccak_p_aux_loop (a : StateArray) (ir : Usize) : Result StateArray :=
  if ir < 24#usize
  then
    do
    let a1 ← round a ir
    let ir1 ← ir + 1#usize
    keccak_p_aux_loop a1 ir1
  else ok a
partial_fixpoint

/- [simple::keccak_p_aux]:
   Source: 'src/simple.rs', lines 221:0-227:1 -/
@[reducible]
def keccak_p_aux (a : StateArray) : Result StateArray :=
  keccak_p_aux_loop a 0#usize

/- [simple::keccak_p]:
   Source: 'src/simple.rs', lines 230:0-234:1 -/
def keccak_p (s : Array Bool 1600#usize) : Result (Array Bool 1600#usize) :=
  keccak_p_aux s

/- [simple::sponge_absorb_initial]: loop 0:
   Source: 'src/simple.rs', lines 239:4-244:5 -/
def sponge_absorb_initial_loop
  (bs : Slice Bool) (r : Usize) (s : Array Bool 1600#usize) (n : Usize)
  (i : Usize) :
  Result (Array Bool 1600#usize)
  :=
  if i < n
  then
    do
    let i1 ← r * i
    let i2 ← i + 1#usize
    let i3 ← r * i2
    let chunk ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeUsizeSliceInst Bool) bs
        { start := i1, end_ := i3 }
    let (s1, to_slice_mut_back) ←
      (↑(Array.to_slice_mut s) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let s2 ← xor_long s1 chunk
    let s3 := to_slice_mut_back s2
    let s4 ← keccak_p s3
    sponge_absorb_initial_loop bs r s4 n i2
  else ok s
partial_fixpoint

/- [simple::sponge_absorb_initial]:
   Source: 'src/simple.rs', lines 236:0-245:1 -/
def sponge_absorb_initial
  (bs : Slice Bool) (r : Usize) (s : Array Bool 1600#usize) :
  Result (Array Bool 1600#usize)
  :=
  do
  let i := Slice.len bs
  let n ← i / r
  sponge_absorb_initial_loop bs r s n 0#usize

/- [simple::sponge_absorb_final]:
   Source: 'src/simple.rs', lines 247:0-287:1 -/
def sponge_absorb_final
  (s : Array Bool 1600#usize) (rest : Slice Bool) (suffix : Slice Bool)
  (r : Usize) :
  Result (Array Bool 1600#usize)
  :=
  do
  let (s1, to_slice_mut_back) ←
    (↑(Array.to_slice_mut s) : Result ((Slice Bool) × (Slice Bool → Array
      Bool 1600#usize)))
  let s2 ← xor_long s1 rest
  let i := Slice.len rest
  let i1 := Slice.len suffix
  let nb_left ← i + i1
  if nb_left >= r
  then
    do
    let s3 := to_slice_mut_back s2
    let (s4, to_slice_mut_back1) ←
      (↑(Array.to_slice_mut s3) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let i2 := Slice.len rest
    let i3 ← r - i2
    let s5 ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeUsizeSliceInst Bool) suffix
        { start := 0#usize, end_ := i3 }
    let i4 := Slice.len rest
    let s6 ← xor_long_at s4 s5 i4
    let s7 := to_slice_mut_back1 s6
    let s8 ← keccak_p s7
    let (s9, to_slice_mut_back2) ←
      (↑(Array.to_slice_mut s8) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let i5 := Slice.len rest
    let i6 ← r - i5
    let s10 ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeFromUsizeSlice Bool) suffix
        { start := i6 }
    let s11 ← xor_long s9 s10
    let s12 := to_slice_mut_back2 s11
    let (s13, to_slice_mut_back3) ←
      (↑(Array.to_slice_mut s12) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let s14 ←
      (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice Bool))
    let i7 ← nb_left - r
    let s15 ← xor_long_at s13 s14 i7
    let s16 := to_slice_mut_back3 s15
    let (s17, to_slice_mut_back4) ←
      (↑(Array.to_slice_mut s16) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let s18 ←
      (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice Bool))
    let i8 ← r - 1#usize
    let s19 ← xor_long_at s17 s18 i8
    let s20 := to_slice_mut_back4 s19
    keccak_p s20
  else
    do
    let s3 := to_slice_mut_back s2
    let (s4, to_slice_mut_back1) ←
      (↑(Array.to_slice_mut s3) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let i2 := Slice.len rest
    let s5 ← xor_long_at s4 suffix i2
    let s6 := to_slice_mut_back1 s5
    let (s7, to_slice_mut_back2) ←
      (↑(Array.to_slice_mut s6) : Result ((Slice Bool) × (Slice Bool →
        Array Bool 1600#usize)))
    let s8 ←
      (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice Bool))
    let s9 ← xor_long_at s7 s8 nb_left
    let i3 ← nb_left + 1#usize
    if i3 < r
    then
      do
      let s10 := to_slice_mut_back2 s9
      let (s11, to_slice_mut_back3) ←
        (↑(Array.to_slice_mut s10) : Result ((Slice Bool) × (Slice Bool →
          Array Bool 1600#usize)))
      let s12 ←
        (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
          Bool))
      let i4 ← r - 1#usize
      let s13 ← xor_long_at s11 s12 i4
      let s14 := to_slice_mut_back3 s13
      keccak_p s14
    else
      do
      let s10 := to_slice_mut_back2 s9
      let s11 ← keccak_p s10
      let (s12, to_slice_mut_back3) ←
        (↑(Array.to_slice_mut s11) : Result ((Slice Bool) × (Slice Bool →
          Array Bool 1600#usize)))
      let s13 ←
        (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
          Bool))
      let i4 ← r - 1#usize
      let s14 ← xor_long_at s12 s13 i4
      let s15 := to_slice_mut_back3 s14
      keccak_p s15

/- [simple::sponge_absorb]:
   Source: 'src/simple.rs', lines 289:0-294:1 -/
def sponge_absorb
  (bs : Slice Bool) (r : Usize) (s : Array Bool 1600#usize)
  (suffix : Slice Bool) :
  Result (Array Bool 1600#usize)
  :=
  do
  let s1 ← sponge_absorb_initial bs r s
  let i := Slice.len bs
  let n ← i / r
  let i1 ← r * n
  let rest ←
    core.slice.index.Slice.index
      (core.slice.index.SliceIndexRangeFromUsizeSlice Bool) bs { start := i1 }
  sponge_absorb_final s1 rest suffix r

/- Trait implementation: [core::marker::{core::marker::Copy for bool}#53]
   Source: '/rustc/library/core/src/marker.rs', lines 55:25-55:62
   Name pattern: [core::marker::Copy<bool>] -/
@[reducible]
def core.marker.CopyBool : core.marker.Copy Bool := {
  cloneInst := core.clone.CloneBool
}

/- [simple::sponge_squeeze]: loop 0:
   Source: 'src/simple.rs', lines 300:4-310:5 -/
def sponge_squeeze_loop
  (r : Usize) (z : Slice Bool) (s : Array Bool 1600#usize) (i : Usize) :
  Result (Slice Bool)
  :=
  do
  let i1 ← i + r
  let i2 := Slice.len z
  if i1 < i2
  then
    do
    let (s1, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeUsizeSliceInst Bool) z
        { start := i, end_ := i1 }
    let s2 ←
      core.array.Array.index (core.ops.index.IndexSliceInst
        (core.slice.index.SliceIndexRangeUsizeSliceInst Bool)) s
        { start := 0#usize, end_ := r }
    let s3 ← core.slice.Slice.copy_from_slice core.marker.CopyBool s1 s2
    let s4 ← keccak_p s
    let z1 := index_mut_back s3
    sponge_squeeze_loop r z1 s4 i1
  else
    do
    let i3 := Slice.len z
    let nb_left ← i3 - i
    let (s1, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeFromUsizeSlice Bool) z { start := i }
    let s2 ←
      core.array.Array.index (core.ops.index.IndexSliceInst
        (core.slice.index.SliceIndexRangeUsizeSliceInst Bool)) s
        { start := 0#usize, end_ := nb_left }
    let s3 ← core.slice.Slice.copy_from_slice core.marker.CopyBool s1 s2
    ok (index_mut_back s3)
partial_fixpoint

/- [simple::sponge_squeeze]:
   Source: 'src/simple.rs', lines 297:0-311:1 -/
@[reducible]
def sponge_squeeze
  (r : Usize) (z : Slice Bool) (s : Array Bool 1600#usize) :
  Result (Slice Bool)
  :=
  sponge_squeeze_loop r z s 0#usize

/- [simple::sponge]:
   Source: 'src/simple.rs', lines 313:0-317:1 -/
def sponge
  (r : Usize) (bs : Slice Bool) (output : Slice Bool) (suffix : Slice Bool) :
  Result (Slice Bool)
  :=
  do
  let s := Array.repeat 1600#usize false
  let s1 ← sponge_absorb bs r s suffix
  sponge_squeeze r output s1

/- [simple::SHA3_SUFFIX]
   Source: 'src/simple.rs', lines 319:0-319:45 -/
@[global_simps]
def SHA3_SUFFIX_body : Result (Array Bool 2#usize) :=
  ok (Array.make 2#usize [ false, true ])
@[global_simps, irreducible]
def SHA3_SUFFIX : Array Bool 2#usize := eval_global SHA3_SUFFIX_body

/- [simple::sha3_224]:
   Source: 'src/simple.rs', lines 320:0-320:141 -/
def sha3_224 (bs : Slice Bool) : Result (Array Bool 224#usize) :=
  do
  let output := Array.repeat 224#usize false
  let i ← 2#usize * 224#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
      Array Bool 224#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::sha3_256]:
   Source: 'src/simple.rs', lines 321:0-321:141 -/
def sha3_256 (bs : Slice Bool) : Result (Array Bool 256#usize) :=
  do
  let output := Array.repeat 256#usize false
  let i ← 2#usize * 256#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
      Array Bool 256#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::sha3_384]:
   Source: 'src/simple.rs', lines 322:0-322:141 -/
def sha3_384 (bs : Slice Bool) : Result (Array Bool 384#usize) :=
  do
  let output := Array.repeat 384#usize false
  let i ← 2#usize * 384#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
      Array Bool 384#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::sha3_512]:
   Source: 'src/simple.rs', lines 323:0-323:141 -/
def sha3_512 (bs : Slice Bool) : Result (Array Bool 512#usize) :=
  do
  let output := Array.repeat 512#usize false
  let i ← 2#usize * 512#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
      Array Bool 512#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::SHAKE_SUFFIX]
   Source: 'src/simple.rs', lines 325:0-325:42 -/
@[global_simps]
def SHAKE_SUFFIX_body : Result (Array Bool 4#usize) :=
  ok (Array.repeat 4#usize true)
@[global_simps, irreducible]
def SHAKE_SUFFIX : Array Bool 4#usize := eval_global SHAKE_SUFFIX_body

/- [simple::shake128]:
   Source: 'src/simple.rs', lines 326:0-326:99 -/
def shake128 (bs : Slice Bool) (output : Slice Bool) : Result (Slice Bool) :=
  do
  let i ← 2#usize * 128#usize
  let i1 ← B - i
  let s ← (↑(Array.to_slice SHAKE_SUFFIX) : Result (Slice Bool))
  sponge i1 bs output s

/- [simple::shake256]:
   Source: 'src/simple.rs', lines 327:0-327:99 -/
def shake256 (bs : Slice Bool) (output : Slice Bool) : Result (Slice Bool) :=
  do
  let i ← 2#usize * 256#usize
  let i1 ← B - i
  let s ← (↑(Array.to_slice SHAKE_SUFFIX) : Result (Slice Bool))
  sponge i1 bs output s

end simple
